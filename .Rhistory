test_data_ultra$Survived <- bi_prediction
#the final output!
final_output_evil <- data.frame(PassengerId = test_data_ultra$PassengerId, Survived = test_data_ultra$Survived)
#write its down
write.csv(final_output_evil, "final_predictions_rf.csv", row.names = FALSE)
rm( list = ls())
# loding the package and some basic setting.
library(tidyverse)
library(dplyr)
library(fpp2)
library(glmnet)
library(tidyr)
library(lmtest)
library(boot)
library(forecast)
library(readr)
library(ggfortify)
library(tseries)
library(urca)
library(readxl)
library(lubridate)
library(tsbox)
library(RColorBrewer)
library(wesanderson)
library(writexl)
library(gridExtra)
library(vars)
library(leaps)
library(broom)
library(fastDummies)
library(car)
#setting the saving addreess
setwd("/Users/tie/Documents/GitHub/The-data-analysis-job--")
#loding the data
Titanic_train_raw <- read_csv("Titanic data/train.csv",
col_types = cols( Name = col_skip(), Ticket = col_skip(),
Cabin = col_skip()))
#check the number of NA in the data set
print(colSums(is.na(Titanic_train_raw )))
hist(Titanic_train_raw$Age, main = "Histogram of Age", xlab = "Age", col = "blue", border = "white", breaks = 20)
age_without_na <- na.omit(Titanic_train_raw$Age)
density_age <- density(age_without_na)
plot(density_age, main = "Density Plot of Age", xlab = "Age", ylab = "Density", col = "red")
# Calculate the density
age_density <- density(ages_vector)
# Assuming your dataset is named 'Titanic_train_raw' and the age column is 'Age'
# Remove NA values from the Age column
age_without_na <- na.omit(Titanic_train_raw$Age)
# Calculate the density of the Age data without NA values
age_density <- density(age_without_na)
# Create a density plot of Age
plot(age_density, main = "Density Plot of Age", xlab = "Age", ylab = "Density", col = "red")
# Identify the maximum density value and its corresponding age value
max_density_index <- which.max(age_density$y)
max_density_value <- age_density$y[max_density_index]
mode_age <- age_density$x[max_density_index]
# Output the age with the maximum density value
cat("The age with the maximum density value is:", mode_age, "with a density of:", max_density_value, "\n")
rm( list = ls())
# loding the package and some basic setting.
library(tidyverse)
library(dplyr)
library(fpp2)
library(glmnet)
library(tidyr)
library(lmtest)
library(boot)
library(forecast)
library(readr)
library(ggfortify)
library(tseries)
library(urca)
library(readxl)
library(lubridate)
library(tsbox)
library(RColorBrewer)
library(wesanderson)
library(writexl)
library(gridExtra)
library(vars)
library(leaps)
library(broom)
library(fastDummies)
library(car)
#setting the saving addreess
setwd("/Users/tie/Documents/GitHub/The-data-analysis-job--")
#the average age between who subdivided and who does not
mean_age_by_survival <- aggregate(Age ~ Survived, data = Titanic_train_raw, FUN = function(x) mean(x, na.rm = TRUE))
#loding the data
Titanic_train_raw <- read_csv("Titanic data/train.csv",
col_types = cols( Name = col_skip(), Ticket = col_skip(),
Cabin = col_skip()))
#check the number of NA in the data set
print(colSums(is.na(Titanic_train_raw )))
#the average age between who subdivided and who does not
mean_age_by_survival <- aggregate(Age ~ Survived, data = Titanic_train_raw, FUN = function(x) mean(x, na.rm = TRUE))
print(mean_age_by_survival )
print(summary(Titanic_train_raw$Age))
Titanic_train_raw
#the average age between who subdivided and who does not
mean_age_by_survival <- aggregate(Age ~ Survived, data = Titanic_train_raw, FUN = function(x) mean(x, na.rm = TRUE))
print(mean_age_by_survival )
#3.The model comparsing
#TTD
#cut the date in the 2 part
#select 90% for the training
#select 10% for the testing
#calculate how many row in the TTD data set
cut_data<- sample(1:nrow(TTD), size = 9/10* nrow(TTD), replace = FALSE)
########## The Ridge Regression Time ##########
# using the cross vaildation to find the optimal lambda
ridge.cv <- cv.glmnet(x, live, alpha = 0, nfolds = 5)
par(mfrow=c(1,3))
# Plot RSS
plot(reg_summary$rss, xlab = "Number of Variables", ylab = "RSS", type = "l")
#create a new matrix
x <- TTD %>%
dplyr::select(
Pclass, Age, SibSp, Parch, Fare, Embarked, Sex_female
) %>%
data.matrix()
vif(data_test_1)
#crate a new matrix
x <- TTD%>%
dplyr::select(
Pclass, Age, SibSp, Parch, Fare, Embarked, Sex_female
) %>%
data.matrix()
par(mfrow = c(3, 2))
#the grpahy per class
barplot(table(TTD$Survived, TTD$Pclass), beside = TRUE,
main = "Survived by Pclass", xlab = "Pclass", ylab = "Count")
#replace the missing value with the average
Titanic_train_raw$Age[is.na(Titanic_train_raw$Age)] <- The_average_age
#the average age of the entire data set
The_average_age <- mean(Titanic_train_raw$Age, na.rm = TRUE)
print(The_average_age)
#replace the missing value with the average
Titanic_train_raw$Age[is.na(Titanic_train_raw$Age)] <- The_average_age
Titanic_train_without_age_gap <- Titanic_train_raw
#delete the 2 line in the embarked
Titanic_train_cleaned <- na.omit(Titanic_train_without_age_gap)
#transer it into the the tranning data set with dummy vaiaralbe.
TTD<- dummy_cols(Titanic_train_cleaned, select_columns = "Sex", remove_selected_columns = TRUE)
par(mfrow = c(3, 2))
#the grpahy per class
barplot(table(TTD$Survived, TTD$Pclass), beside = TRUE,
main = "Survived by Pclass", xlab = "Pclass", ylab = "Count")
legend("top", legend = c("0: Died", "1: Survived"), fill = c("black", "white"))
# Age Boxplot
boxplot(Age ~ Survived, data = TTD,
col = c("orange", "gray"),
main = "Survived by Age",
xlab = "Survived", ylab = "Age")
legend("top", legend = c("0: Died", "1: Survived"), fill = c("orange", "gray"))
# SibSp
survival_table_sibsp <- table(TTD$Survived, TTD$SibSp)
barplot(survival_table_sibsp, beside = TRUE, col = c("black", "gray"),
main = "Survived by SibSp", xlab = "SibSp", ylab = "Count")
legend("topright", legend = c("0: Died", "1: Survived"), fill = c("black", "gray"))
# The parch
stripchart(Parch ~ Survived, data = TTD, vertical = TRUE, method = "jitter",
pch = 20, col = c("black", "gray"),
main = " Survived by parch",
xlab = "Survived", ylab = "Parch")
legend("top", legend = c("0: Died", "1: Survived"), fill = c("black", "gray"))
# The fare(The price of ticket)
boxplot(Fare ~ Survived, data = TTD,
col = c("orange", "gray"),
main = "Survived by Fare",
xlab = "Survived", ylab = "Fare")
legend("top", legend = c("0: Died", "1: Survived"), fill = c("black", "gray"))
#The sex
female_table <- table(TTD$Sex_female, TTD$Survived)
barplot(female_table, beside = TRUE, col = c("black", "gray"),
main = "Survived by Sex", xlab = "Sex", ylab = "Count",
legend = F)
legend("center", legend = c("MALE", "Female"), fill = c("black", "gray"))
#crate a new matrix
x <- TTD%>%
dplyr::select(
Pclass, Age, SibSp, Parch, Fare, Embarked, Sex_female
) %>%
data.matrix()
#take out the survive
live <- TTD$Survived
#put two things together as data frame
data2 <- data.frame(x, live)
#The BP test
data_test_1 <- lm(live ~ . , data = data2)
bptest(data_test_1)
vif(data_test_1)
#create a new matrix
x <- TTD %>%
dplyr::select(
Pclass, Age, SibSp, Parch, Fare, Embarked, Sex_female
) %>%
data.matrix()
#take out the survived data.
live <- TTD$Survived
#The data frame time!
data2 <- data.frame(x, live)
#using regression to search all the possible output
regfit_all <- regsubsets(live ~ ., data = data2, nvmax = 10)
reg_summary <- summary(regfit_all)
# ploting the result.
plot(regfit_all, scale = "bic")
par(mfrow=c(1,3))
# Plot RSS
plot(reg_summary$rss, xlab = "Number of Variables", ylab = "RSS", type = "l")
# Plot BIC with highlighted minimum point
plot(reg_summary$bic, xlab = "Number of Variables", ylab = "BIC", type = "l")
m.bic <- which.min(reg_summary$bic) # Find the index of minimum BIC
points(m.bic, reg_summary$bic[m.bic], col = "red", cex = 2, pch = 20) # Highlight the min point
# Plot Cp with highlighted minimum point
plot(reg_summary$cp, xlab = "Number of Variables", ylab = "Cp", type = "l")
m.cp <- which.min(reg_summary$cp) # Find the index of minimum Cp
points(m.cp, reg_summary$cp[m.cp], col = "red", cex = 2, pch = 20) # Highlight the min point
########## The Ridge Regression Time ##########
# using the cross vaildation to find the optimal lambda
ridge.cv <- cv.glmnet(x, live, alpha = 0, nfolds = 5)
# imput the corss vaildation
coef_ridge <- as.vector(coef(ridge.cv, s = "lambda.min")[-1])
#OLS time
ols_mod <- lm(live ~ ., data = data2)
coef_ols <- coef(ols_mod)[-1]
# Create a data frame for comparison
variable_names <- names(coef_ols)
#put all the result together.
performence_table <- data.frame(
Variable = variable_names,
OLS = coef_ols,
Ridge = coef_ridge)
# Display the comparison table sorted by Ridge coefficients
performence_table_ordered <- performence_table[order(performence_table$Ridge), ]
# Display the sorted comparison table
print(performence_table_ordered)
#3.The model comparsing
#TTD
#cut the date in the 2 part
#select 90% for the training
#select 10% for the testing
#calculate how many row in the TTD data set
cut_data<- sample(1:nrow(TTD), size = 9/10* nrow(TTD), replace = FALSE)
#select the 90% of the data set for the training
training_set <- TTD[cut_data, ]
#rest of 10% for the test
testing_set <- TTD[-cut_data, ]
# Fit the logistic regression model
model1 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp, data = training_set)
model2 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp, family = binomial, data = training_set)
model3 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, data = training_set)
model4 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, family = binomial, data = training_set)
# Making predictions on the test set for each model
model1_pred <- predict(model1, newdata = testing_set)
model2_pred <- predict(model2, newdata = testing_set, type = "response")
model3_pred <- predict(model3, newdata = testing_set)
model4_pred <- predict(model4, newdata = testing_set, type = "response")
# Actual values
test_time <- testing_set$Survived
# Calculate MSE, RMSE, and MAE for each group
#for the model_1
model1_MSE <- mean((test_time -model1_pred)^2)
model1_RMSE <- sqrt(mean((test_time -model1_pred)^2))
model1_MAE <- mean(abs(test_time -model1_pred))
#for the model_2
model2_MSE <- mean((test_time -model2_pred)^2)
model2_RMSE <- sqrt(mean((test_time -model2_pred)^2))
model2_MAE <- mean(abs(test_time -model2_pred))
#for the model_3
model3_MSE <- mean((test_time -model3_pred)^2)
model3_RMSE <- sqrt(mean((test_time -model3_pred)^2))
model3_MAE <- mean(abs(test_time -model3_pred))
#for the model_4
model4_MSE <- mean((test_time -model4_pred)^2)
model4_RMSE <- sqrt(mean((test_time -model4_pred)^2))
model4_MAE <- mean(abs(test_time -model4_pred))
#kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
#The final result
# Kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
# The final result
The_final_table <- data.frame(
Test = c("MSE", "RMSE", "MAE", "Kaggle Scale"),
Model_1_lm = c(model1_MSE, model1_RMSE, model1_MAE, kaggle_scale[1]),
Model_1_glm = c(model2_MSE, model2_RMSE, model2_MAE, kaggle_scale[2]),
Model_2_lm = c(model3_MSE, model3_RMSE, model3_MAE, kaggle_scale[3]),
Model_2_glm = c(model4_MSE, model4_RMSE, model4_MAE, kaggle_scale[4])
)
# Print the final result
print(The_final_table)
#3.The model comparsing
#TTD
#cut the date in the 2 part
#select 90% for the training
#select 10% for the testing
#calculate how many row in the TTD data set
cut_data<- sample(1:nrow(TTD), size = 9/10* nrow(TTD), replace = FALSE)
#select the 90% of the data set for the training
training_set <- TTD[cut_data, ]
#rest of 10% for the test
testing_set <- TTD[-cut_data, ]
# Fit the logistic regression model
model1 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp, data = training_set)
model2 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp, family = binomial, data = training_set)
model3 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, data = training_set)
model4 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, family = binomial, data = training_set)
# Making predictions on the test set for each model
model1_pred <- predict(model1, newdata = testing_set)
model2_pred <- predict(model2, newdata = testing_set, type = "response")
model3_pred <- predict(model3, newdata = testing_set)
model4_pred <- predict(model4, newdata = testing_set, type = "response")
# Actual values
test_time <- testing_set$Survived
# Calculate MSE, RMSE, and MAE for each group
#for the model_1
model1_MSE <- mean((test_time -model1_pred)^2)
model1_RMSE <- sqrt(mean((test_time -model1_pred)^2))
model1_MAE <- mean(abs(test_time -model1_pred))
#for the model_2
model2_MSE <- mean((test_time -model2_pred)^2)
model2_RMSE <- sqrt(mean((test_time -model2_pred)^2))
model2_MAE <- mean(abs(test_time -model2_pred))
#for the model_3
model3_MSE <- mean((test_time -model3_pred)^2)
model3_RMSE <- sqrt(mean((test_time -model3_pred)^2))
model3_MAE <- mean(abs(test_time -model3_pred))
#for the model_4
model4_MSE <- mean((test_time -model4_pred)^2)
model4_RMSE <- sqrt(mean((test_time -model4_pred)^2))
model4_MAE <- mean(abs(test_time -model4_pred))
#kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
#The final result
# Kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
# The final result
The_final_table <- data.frame(
Test = c("MSE", "RMSE", "MAE", "Kaggle Scale"),
Model_1_lm = c(model1_MSE, model1_RMSE, model1_MAE, kaggle_scale[1]),
Model_1_glm = c(model2_MSE, model2_RMSE, model2_MAE, kaggle_scale[2]),
Model_2_lm = c(model3_MSE, model3_RMSE, model3_MAE, kaggle_scale[3]),
Model_2_glm = c(model4_MSE, model4_RMSE, model4_MAE, kaggle_scale[4])
)
# Print the final result
print(The_final_table)
#3.The model comparsing
#TTD
#cut the date in the 2 part
#select 90% for the training
#select 10% for the testing
#calculate how many row in the TTD data set
cut_data<- sample(1:nrow(TTD), size = 9/10* nrow(TTD), replace = FALSE)
#select the 90% of the data set for the training
training_set <- TTD[cut_data, ]
#rest of 10% for the test
testing_set <- TTD[-cut_data, ]
# Fit the logistic regression model
model1 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp, data = training_set)
model2 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp, family = binomial, data = training_set)
model3 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, data = training_set)
model4 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, family = binomial, data = training_set)
# Making predictions on the test set for each model
model1_pred <- predict(model1, newdata = testing_set)
model2_pred <- predict(model2, newdata = testing_set, type = "response")
model3_pred <- predict(model3, newdata = testing_set)
model4_pred <- predict(model4, newdata = testing_set, type = "response")
# Actual values
test_time <- testing_set$Survived
# Calculate MSE, RMSE, and MAE for each group
#for the model_1
model1_MSE <- mean((test_time -model1_pred)^2)
model1_RMSE <- sqrt(mean((test_time -model1_pred)^2))
model1_MAE <- mean(abs(test_time -model1_pred))
#for the model_2
model2_MSE <- mean((test_time -model2_pred)^2)
model2_RMSE <- sqrt(mean((test_time -model2_pred)^2))
model2_MAE <- mean(abs(test_time -model2_pred))
#for the model_3
model3_MSE <- mean((test_time -model3_pred)^2)
model3_RMSE <- sqrt(mean((test_time -model3_pred)^2))
model3_MAE <- mean(abs(test_time -model3_pred))
#for the model_4
model4_MSE <- mean((test_time -model4_pred)^2)
model4_RMSE <- sqrt(mean((test_time -model4_pred)^2))
model4_MAE <- mean(abs(test_time -model4_pred))
#kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
#The final result
# Kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
# The final result
The_final_table <- data.frame(
Test = c("MSE", "RMSE", "MAE", "Kaggle Scale"),
Model_1_lm = c(model1_MSE, model1_RMSE, model1_MAE, kaggle_scale[1]),
Model_1_glm = c(model2_MSE, model2_RMSE, model2_MAE, kaggle_scale[2]),
Model_2_lm = c(model3_MSE, model3_RMSE, model3_MAE, kaggle_scale[3]),
Model_2_glm = c(model4_MSE, model4_RMSE, model4_MAE, kaggle_scale[4])
)
# Print the final result
print(The_final_table)
#3.The model comparsing
#TTD
#cut the date in the 2 part
#select 90% for the training
#select 10% for the testing
#calculate how many row in the TTD data set
cut_data<- sample(1:nrow(TTD), size = 9/10* nrow(TTD), replace = FALSE)
#select the 90% of the data set for the training
training_set <- TTD[cut_data, ]
#rest of 10% for the test
testing_set <- TTD[-cut_data, ]
# Fit the logistic regression model
model1 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp, data = training_set)
model2 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp, family = binomial, data = training_set)
model3 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, data = training_set)
model4 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, family = binomial, data = training_set)
# Making predictions on the test set for each model
model1_pred <- predict(model1, newdata = testing_set)
model2_pred <- predict(model2, newdata = testing_set, type = "response")
model3_pred <- predict(model3, newdata = testing_set)
model4_pred <- predict(model4, newdata = testing_set, type = "response")
# Actual values
test_time <- testing_set$Survived
# Calculate MSE, RMSE, and MAE for each group
#for the model_1
model1_MSE <- mean((test_time -model1_pred)^2)
model1_RMSE <- sqrt(mean((test_time -model1_pred)^2))
model1_MAE <- mean(abs(test_time -model1_pred))
#for the model_2
model2_MSE <- mean((test_time -model2_pred)^2)
model2_RMSE <- sqrt(mean((test_time -model2_pred)^2))
model2_MAE <- mean(abs(test_time -model2_pred))
#for the model_3
model3_MSE <- mean((test_time -model3_pred)^2)
model3_RMSE <- sqrt(mean((test_time -model3_pred)^2))
model3_MAE <- mean(abs(test_time -model3_pred))
#for the model_4
model4_MSE <- mean((test_time -model4_pred)^2)
model4_RMSE <- sqrt(mean((test_time -model4_pred)^2))
model4_MAE <- mean(abs(test_time -model4_pred))
#kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
#The final result
# Kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
# The final result
The_final_table <- data.frame(
Test = c("MSE", "RMSE", "MAE", "Kaggle Scale"),
Model_1_lm = c(model1_MSE, model1_RMSE, model1_MAE, kaggle_scale[1]),
Model_1_glm = c(model2_MSE, model2_RMSE, model2_MAE, kaggle_scale[2]),
Model_2_lm = c(model3_MSE, model3_RMSE, model3_MAE, kaggle_scale[3]),
Model_2_glm = c(model4_MSE, model4_RMSE, model4_MAE, kaggle_scale[4])
)
# Print the final result
print(The_final_table)
#3.The model comparsing
#TTD
#cut the date in the 2 part
#select 90% for the training
#select 10% for the testing
#calculate how many row in the TTD data set
cut_data<- sample(1:nrow(TTD), size = 9/10* nrow(TTD), replace = FALSE)
#select the 90% of the data set for the training
training_set <- TTD[cut_data, ]
#rest of 10% for the test
testing_set <- TTD[-cut_data, ]
# Fit the logistic regression model
model1 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp, data = training_set)
model2 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp, family = binomial, data = training_set)
model3 <- lm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, data = training_set)
model4 <- glm(Survived ~ Pclass + Sex_female + Age + SibSp + Embarked, family = binomial, data = training_set)
# Making predictions on the test set for each model
model1_pred <- predict(model1, newdata = testing_set)
model2_pred <- predict(model2, newdata = testing_set, type = "response")
model3_pred <- predict(model3, newdata = testing_set)
model4_pred <- predict(model4, newdata = testing_set, type = "response")
# Actual values
test_time <- testing_set$Survived
# Calculate MSE, RMSE, and MAE for each group
#for the model_1
model1_MSE <- mean((test_time -model1_pred)^2)
model1_RMSE <- sqrt(mean((test_time -model1_pred)^2))
model1_MAE <- mean(abs(test_time -model1_pred))
#for the model_2
model2_MSE <- mean((test_time -model2_pred)^2)
model2_RMSE <- sqrt(mean((test_time -model2_pred)^2))
model2_MAE <- mean(abs(test_time -model2_pred))
#for the model_3
model3_MSE <- mean((test_time -model3_pred)^2)
model3_RMSE <- sqrt(mean((test_time -model3_pred)^2))
model3_MAE <- mean(abs(test_time -model3_pred))
#for the model_4
model4_MSE <- mean((test_time -model4_pred)^2)
model4_RMSE <- sqrt(mean((test_time -model4_pred)^2))
model4_MAE <- mean(abs(test_time -model4_pred))
#kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
#The final result
# Kaggle scale
kaggle_scale <- c(0.76794, 0.76794, 0.77033, 0.77033)
# The final result
The_final_table <- data.frame(
Test = c("MSE", "RMSE", "MAE", "Kaggle Scale"),
Model_1_lm = c(model1_MSE, model1_RMSE, model1_MAE, kaggle_scale[1]),
Model_1_glm = c(model2_MSE, model2_RMSE, model2_MAE, kaggle_scale[2]),
Model_2_lm = c(model3_MSE, model3_RMSE, model3_MAE, kaggle_scale[3]),
Model_2_glm = c(model4_MSE, model4_RMSE, model4_MAE, kaggle_scale[4])
)
# Print the final result
print(The_final_table)
